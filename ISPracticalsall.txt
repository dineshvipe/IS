import java.util.Scanner;
public class Caesar_Cipher 
{
    private String inputstring;
    private int key;
    private char cipher[],encrypt[],decrypt[];
    public void Getinput()
    {
        System.out.println("Enter Plain Text:");
        Scanner sc=new Scanner(System.in);
        inputstring=sc.nextLine();
        
        //for removing extra symbols
        String text1=inputstring.replaceAll("[^a-zA-Z]", "");
        String preprocessedtext=text1.toLowerCase();
        System.out.println("Preprocessed Text:");
        System.out.println(""+preprocessedtext);
        System.out.println("Enter value of K");
        key=sc.nextInt();
        
        cipher=preprocessedtext.toCharArray();
        encrypt=new char[cipher.length];
        decrypt=new char[cipher.length];
        
        display(key,preprocessedtext,cipher,encrypt,decrypt);
    }
    char[] EncryptFunc(String preprotext)
    {
        //ascii value for small a-z=97 to 122 and for A-Z= 65 - 90
        for(int i=0;i<cipher.length;i++)
            encrypt[i]=(char)((((cipher[i]-97)+(int)key)%26)+97);
        
        return encrypt;
    }
   
    String DecryptFunc(char[] encrypt,char[] cipher,char[] decrypt,int key)
    {
        for(int i=0;i<cipher.length;i++)
        {
            int val=(encrypt[i]-97-key);
            if(val<0)
                decrypt[i]=(char)((((val+26))%26)+97);
            else
                decrypt[i]=(char)((val%26)+97);
        }
        String decryption="";
        for(int i=0;i<decrypt.length;i++)
        {
            decryption = decryption + decrypt[i];
            System.out.print(""+decrypt[i]);
        }
            
        System.out.println("");
        return decryption;
    }
    
    
    void display(int key,String prepro_text,char[] encryptedtext,char[] cipher,char[] decrypt)
    {
        //for encryption
        System.out.println("Encrypting Plain Text:");
        encryptedtext = EncryptFunc(prepro_text);
        for(int i=0;i<encryptedtext.length;i++)
            System.out.print(""+encryptedtext[i]);
        
        System.out.println("");
        
        //for decryption
        System.out.println("Decrypting Plain Text:");
        DecryptFunc(encryptedtext,cipher,decrypt,key);
        
        System.out.println("\nDecryption by brute force technique");
        String decryp;
        int brutekey=0;
        for(int k=0;k<26;k++)
        {
            System.out.println("For K="+k+": ");
            decryp=DecryptFunc(encryptedtext,cipher,decrypt,k);
            if(decryp.equals(prepro_text))
                brutekey = k;
            System.out.println("");            
        }
        
        System.out.println("\tHence, for K = "+brutekey+
                "\t\nWe got the reult using brute force technique.");
    }

}
 
//for lineno. 92
/*The .equals() method will check if the two strings have the same value. 
Strings in Java are immutable. ... When using == operator for string comparison 
you are not comparing the contents of the string, but are actually comparing 
the memory address. If they are both equal it will return true and false otherwise.
*/

/*
OUTPUT:-

Enter Plain Text:
Hello world
Preprocessed Text:
helloworld
Enter value of K
3
Encrypting Plain Text:
khoorzruog
Decrypting Plain Text:
helloworld

Decryption by brute force technique
For K=0: 
khoorzruog

For K=1: 
jgnnqyqtnf

	Hence, for K = 3	
We got the reult using brute force technique.
*/




















import java.util.ArrayList;
import java.util.Map;
import java.util.Scanner;
import java.util.TreeMap;

public class ISPractical2 
{
    private String inputtext;
    private String key;
    public void Getinput()
    {
        System.out.println("\nThis is IS practical2"
                + "\nAIM: Demonstration of Single and Double Columnar Transposition");
        String inputstr;
        Scanner s =new Scanner(System.in);
        System.out.println("Enter the message to decrypt:-");
        inputstr = s.nextLine();
        inputstr = inputstr.replaceAll("[^a-zA-Z]", "");
        inputtext = inputstr.toLowerCase();
        
        System.out.println("Enter the key term:-");
        key = s.next();
        
        System.out.println("\t\nEnter your choice:-"+
                "\n1.Single Columnar Transposition"+
                "\n2.Double Columnar Transposition"+
                "\n3.Exit");
        int choice = s.nextInt();
        
        Display(inputtext, key,choice);      
    }
    
    String encrypt(String message,String key)
    {
        ArrayList<Character[]> al = new ArrayList<>();      
        TreeMap<Character,String> sortedmatrix = new TreeMap<>();
        int s = key.length();
        Character c[] = new Character[s];
        int k=0;       
        //for creating matrix
        for(int i=0;i<message.length();i++)
        {
            c[k++]=message.charAt(i);
            if(k==s || (i==message.length()-1))
            {
                if(k!=s){
                    while(k!=s)
                        c[k++]='X';
                }
                al.add(c);
                k=0;
                
                c = new Character[s];
            }
        }       
        System.out.println("Printing matrix according to key:-");
        for(int i=0;i<key.length();i++)
        {
            System.out.print(Integer.parseInt(""+key.charAt(i))+" ");
        }
        System.out.println("");
              
        for(int i=0;i<al.size();i++)
        {
            for(int j=0;j<key.length();j++)
            {
                System.out.print(al.get(i)[j]+" "); 
            }
            //sorted.put(key.charAt(i), al.get(i));
            System.out.println("");
        }
        
        String forhash= "";
        for(int j=0;j<key.length();j++)
        {
            for(int i=0;i<al.size();i++)
            {
                forhash=forhash+al.get(i)[j];
                sortedmatrix.put(key.charAt(j), forhash);
                
            }
            forhash= "";
        }        
        //int l= sortedmatrix.size();
        //System.out.println(""+l);       
        //sorted.putAll(map);
        String encrypto = "";
        for (Map.Entry<Character,String> entry : sortedmatrix.entrySet())
        {//System.out.println("Key = "+entry.getKey()+",Value = " + entry.getValue());            
            encrypto = encrypto+entry.getValue();           
        }             
       return encrypto;        
    }
    
    String decrypt(String cipher , String key)
    {
        String decrypt="";
        int k=0;   
        int col = key.length();int row = cipher.length()/col;
        char [][]dmat= new char[row][col];
        for(int i=0;i <col;i++)
        {
            for(int j=0; j < row ;j++ )
            {
                dmat[j][i]=cipher.charAt(k);
                k++;
            }
        }

        System.out.println("\ndecrypted matrix");
        for(int i=0;i <row;i++)
        {
            for(int j=0; j < col ;j++ )
            {
                System.out.print(""+dmat[i][j]+" ");
            }
            System.out.println("");
        }

        k=0;

        char temp[][]=new char[row][col];
        while(k<col)
        {
            for(int i=0;i <col;i++)
            {
                if(k==col)
                    break;                
                //int ax=Character.getNumericValue(key.charAt(k))-1;
                //note use of getNumericValue get numeric value otherwise ascii values will be given.
                if(i == Character.getNumericValue(key.charAt(k))-1)
                {                   
                    for(int j=0; j < row ;j++ )
                    {                       
                        temp[j][k]=dmat[j][i];  //changing column according to original key                  
                    }
                    k++;
                }

            }
        }

        System.out.println("\nswapped matrix");
        for(int i=0;i <row;i++)
        {
            for(int j=0; j < col ;j++ )
            {
                System.out.print(""+temp[i][j]+" ");
                decrypt =decrypt+temp[i][j];

            }
            System.out.println("");
        }
        return decrypt;
    }   
    
    void Display(String message,String key,int choice)
    {
        System.out.println("Plain Text : "+inputtext);
        System.out.println("Key(Numeric) : "+key);
        System.out.println("");
        switch(choice)
        {
            case 1: String encrypt= encrypt(inputtext,key);           
                    String decrypt= decrypt(encrypt,key);
                    System.out.println("\t\nDemonstration of Single Columnar Transposition:-\n");
                    System.out.println("Original Message : "+inputtext);
                    System.out.println("Encryption : "+encrypt);
                    System.out.println("Decryption : "+decrypt);
                    break;

            case 2: Scanner s =new Scanner(System.in);
                    System.out.println("Enter the second key:-");
                    String key2 = s.next();
                    String encrypt1 = encrypt(inputtext,key);
                    String encrypt2 = encrypt(encrypt1,key2);            
                    String decrypt2 = decrypt(encrypt2,key2);
                    String decrypt1 = decrypt(decrypt2,key);
                    System.out.println("\tDemonstration of Double Columnar Transposition:-\n");
                    System.out.println("Original Message : "+inputtext);
                    System.out.println("1st Encryption : "+encrypt1);
                    System.out.println("2nd Encryption : "+encrypt2);
                    System.out.println("Decryption of 2nd Encryption : "+decrypt2);
                    System.out.println("Final Decryption : "+decrypt1);                    
                    break;

           default: System.out.println("\t\t!!!!! Exiting !!!!!");


        }     
        
        
    }
}
















import java.util.Scanner;
public class ISPractical3 
{
    Scanner s =new Scanner(System.in);
    char cont = 'y';
    
    public void getinput()
    {
        
            System.out.println("\n\n\tPlease enter your choice:"
            + "\n1.Autokeycipher\n2.Vigenre cipher"
            + "\n3.Exit");
            int select = s.nextInt();
            switch(select)
            {
                case 1: AutokeyCipher a = new AutokeyCipher();
                        a.Getinput();
                        break;

                case 2: VigenreCipher v = new VigenreCipher();
                        v.Getinputv();
                        break;

                 default: System.out.println("\t\t!!!!! Exiting !!!!!");
                        

            }
        
        
        
    }

}

class AutokeyCipher 
{
    private static final String Set_of_alphabets = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    private String inputtext;
    private String key;
    //private char keystream[];
    void Getinput()
    {
        String inputstr,k;
        Scanner s =new Scanner(System.in);
        System.out.println("Enter the message to decrypt:-");
        inputstr = s.nextLine();
        inputstr = inputstr.replaceAll("[^a-zA-Z]", "");
        inputtext = inputstr.toUpperCase();
        
        System.out.println("Enter the key term:-");
        k = s.nextLine();
        k = k.replaceAll("[^a-zA-Z]", "");
        key = k.toUpperCase();
        //key = String.valueOf(k);
        /*if(key.matches("[-+]?\\d*\\.?\\d+"))
        {
            key = ""+alpha.charAt(Integer.parseInt(key));
        } */ 
        
        display();
        
    }
    
    String Encryption(String text,String key)
    {
        int len = text.length();

        String subkey = key + text;
        subkey = subkey.substring(0,subkey.length()-key.length());//key+original string

        String encryptedtext = "";
        for(int x=0;x<len;x++)
        {
            int get1 = Set_of_alphabets.indexOf(text.charAt(x));
            int get2 = Set_of_alphabets.indexOf(subkey.charAt(x));

            int total = (get1 + get2)%26;

            encryptedtext += Set_of_alphabets.charAt(total);
        }
        return encryptedtext;   
   }
   
    String Decryption(String text,String key)
    {
        int len = text.length();
        String current = key;
        String originaltext ="";
        for(int x=0;x<len;x++)
        {
            int get1 = Set_of_alphabets.indexOf(text.charAt(x));
            int get2 = Set_of_alphabets.indexOf(current.charAt(x));

            int total = (get1 - get2)%26;
            total = (total<0)? total + 26 : total;
            originaltext += Set_of_alphabets.charAt(total);

            current += Set_of_alphabets.charAt(total);
        }
        return originaltext;
    }

    void display()
    {
        String enc = Encryption(inputtext,key);
        System.out.println("Plaintext : "+inputtext);
        System.out.println("Encrypted : "+enc);
        System.out.println("Decrypted : "+Decryption(enc,key));
    }
    
}

class VigenreCipher
{
    private static String alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    private String message;
    private String inpkey;
    void Getinputv()
    {
        String inputstr,k;
        Scanner s =new Scanner(System.in);
        System.out.println("Enter the message to decrypt:-");
        inputstr = s.nextLine();
        inputstr = inputstr.replaceAll("[^a-zA-Z]", "");
        message = inputstr.toUpperCase();
        //inputtext = inputstr.toUpperCase();
        /*for(int i=0;i<message.length();i++)
        {
            System.out.println(message.charAt(i));
        }*/
        System.out.println("Enter the key term:-");
        k= s.next();
        inpkey=k.toUpperCase();
        //key = k.toUpperCase();
        //key = String.valueOf(k);      
        display1();
        
    }
    
    String generatekey(String inptext, String key)
    {
        int x = inptext.length(); 
        
        for (int i = 0; ; i++) 
        { 
            if (x == i) 
                i = 0; 
            if (key.length()== inptext.length()) 
                break; 
            key += key.charAt(i);
        } 
        
        return key; 
    }
    
    String Encrypt(String inptext, final String key)
    {
  
        inptext = inptext.toUpperCase();       
        String cipher_text=""; 
        for (int i = 0; i < inptext.length(); i++) 
        { 
            int get1 = alpha.indexOf(inptext.charAt(i));
            int get2 = alpha.indexOf(key.charAt(i));

            int total = (get1 + get2)%26;
            cipher_text += alpha.charAt(total);
            
        } 
        return cipher_text; 
    }

    String Decrypt(String enctext, final String key)
    {

        String orig_text = ""; 
  
        for (int i = 0 ; i < enctext.length(); i++) 
        { 
            int get1 = alpha.indexOf(enctext.charAt(i));
            int get2 = alpha.indexOf(key.charAt(i));
            int x = (get1-get2 + 26) %26;
            
            orig_text += alpha.charAt(x); 
        } 
        return orig_text; 
    }
    
    void display1()
    {
        String key = generatekey(message, inpkey);
        for(int i= 0;i<key.length();i++)
        {
            System.out.println(key.charAt(i));
        }
        String encryptedMsg = Encrypt(message, key);
        System.out.println("String: " + message);
        System.out.println("Encrypted message: " + encryptedMsg);
        System.out.println("Decrypted message: " + Decrypt(encryptedMsg, key));
    }
}

/*
AutoKEY:-
Enter the message to decrypt:-
attack is postponed until two am
Enter the key term:-
pascal
Plaintext : ATTACKISPOSTPONEDUNTILTWOAM
Encrypted : PTLCCVILIOUDXGCSVNCHVPWQBTU
Decrypted : ATTACKISPOSTPONEDUNTILTWOAM

Vigenere:-

Enter the message to decrypt:-
attack is postponed until two am
Enter the key term:-
pascal

String: ATTACKISPOSTPONEDUNTILTWOAM
Encrypted message: PTLCCVXSHQSEEOFGDFCTANTHDAE
Decrypted message: ATTACKISPOSTPONEDUNTILTWOAM

*/






















import java.util.*;
/**
 *
 * @author Piyush
 */
public class ISPractical4 {

    /**
     * @param args the command line arguments
     */
    static String[][] s0={{"01","00","11","10"},{"11","10","01","00"},{"00","10","01","11"},{"11","01","11","10"}};
    static String[][] s1={{"00","01","10","11"},{"10","00","01","11"},{"11","00","01","00"},{"10","01","00","11"}};
    static int[] p4={2,4,3,1};
    static int[] ep={4,1,2,3,2,3,4,1};
    static int[] ip={2,6,3,1,4,8,5,7};
    static int[] ip_inverse={4,1,3,5,7,2,8,6};
    static int[] p10={3,5,2,7,4,10,1,9,8,6};
    static int[] p8={6,3,7,4,8,5,10,9};
    static String initialization_vector="10001000";
    static String initialization_vector_decryption;
    
    public static void main(String[] args) {
        // TODO code application logic here
        Scanner sc=new Scanner(System.in);
        
        /////24 bit input
        System.out.println("Enter the plaintext: ");
        String input_text=sc.next();
        
        int number_of_blocks=ceiling_function(input_text);
       
        String block;
        
        
        int padding=(8*number_of_blocks)-input_text.length();
               for(int i=1;i<=padding;i++)
                   input_text=input_text+"0";
        
        System.out.println("HOW MUCH PADDING: "+padding);
        System.out.println("INPUT TEXT AFTER PADDING: "+input_text);
        
        initialization_vector_decryption=initialization_vector;
        String input;
        String encrypted="";      
                
                System.out.println("Enter the key (10 bits): ");
                String key=sc.next();
                String permuted_key=permutation_key(key);
                String shifted_key=left_shift(permuted_key);
                String compressed_key=compress_key_to_8_bit(shifted_key);
        
                
                //// Left shift by 2 bits 
                String shifted_key_2=left_shift(shifted_key);
                String shifted_key_2_bit=left_shift(shifted_key_2);
                String compressed_key_2=compress_key_to_8_bit(shifted_key_2_bit);
                
        for(int i=1;i<=number_of_blocks;i++)
        {
            
                block=input_text.substring(8*(i-1),8*i);
                input=xor_data_with_key(block,initialization_vector);
                
                
                String permuted_string=permutation_string(input);

                String split_input[]=divide_string_to_half(permuted_string);
                String expanded_input=expand_string(split_input[1]);

                System.out.println("\nENCRYPTION for Block["+i+"]\n");
                    //////ROUND 1
                System.out.println("\nROUND 1");
                System.out.println("permuted_string: "+permuted_string);
                System.out.println("expanded_string: "+expanded_input);
                

                String xor_operate_data=xor_data_with_key(expanded_input,compressed_key);

                String after_xor_operation_data[]=two_halves_data(xor_operate_data);
                String substitution_first_half=substitution_s0(after_xor_operation_data[0]);
                String substitution_second_half=substitution_s1(after_xor_operation_data[1]);
                String after_p4_data=permutation_p4(substitution_first_half+substitution_second_half);

                System.out.println("permuted_key: "+permuted_key);
                System.out.println("compressed_key: "+compressed_key);
                //System.out.println("Shifted key: "+shifted_key);

                System.out.println("xor_operate_data: "+xor_operate_data);
                //System.out.println("substitution_first_half: "+substitution_first_half);
                //System.out.println("substitution_second_half: "+substitution_second_half);
                //System.out.println("after_p4_data: "+after_p4_data);

                String right_half=xor_data_with_key(after_p4_data,split_input[0]);
                String left_half=split_input[1];
                String swapped_string=left_half+right_half;

                //System.out.println("Swapped_string: "+swapped_string);
                //System.out.println("LEFT_HALF: "+left_half);
                //System.out.println("RIGHT_HALF: "+right_half);


                //////ROUND 2
                System.out.println("\nROUND 2");

                String split_input_2[]=divide_string_to_half(swapped_string);
                String expanded_input_2=expand_string(split_input_2[1]);

                String xor_operate_data_2=xor_data_with_key(expanded_input_2,compressed_key_2);

                String after_xor_operation_data_2[]=two_halves_data(xor_operate_data_2);
                String substitution_first_half_2=substitution_s0(after_xor_operation_data_2[0]);
                String substitution_second_half_2=substitution_s1(after_xor_operation_data_2[1]);
                String after_p4_data_2=permutation_p4(substitution_first_half_2+substitution_second_half_2);

                String left_half_2=xor_data_with_key(after_p4_data_2,split_input_2[0]);
                String right_half_2=split_input_2[1];
                String encrypted_string=permutation_inverse_string(left_half_2+right_half_2);

                //System.out.println("expanded_string: "+expanded_input_2);
                //System.out.println("split_string: "+split_input_2[0]+split_input_2[1]);
                System.out.println("compressed_key: "+compressed_key_2);
                //System.out.println("Shifted key: "+shifted_key_2);

                System.out.println("xor_operate_data: "+xor_operate_data_2);
                //System.out.println("substitution_first_half: "+substitution_first_half_2);
                //System.out.println("substitution_second_half: "+substitution_second_half_2);
                //System.out.println("after_p4_data: "+after_p4_data_2);
                //System.out.println("LEFT_HALF: "+left_half_2);
                //System.out.println("RIGHT_HALF: "+right_half_2);
                System.out.println("Encrypted_string: "+encrypted_string);
                
                encrypted=encrypted+encrypted_string;
                initialization_vector=encrypted_string;
            
                
        
        }
        
        System.out.println("FINAL ENCRYPTED STRING: "+encrypted);
        
        
        
        String plaintext="";
        for(int i=1;i<=number_of_blocks;i++)
        {
        
                String block_decryption=encrypted.substring(8*(i-1),8*i);
                
                System.out.println("\nDECRYPTION for Block["+i+"]");
                /////DECRYPTION
                String cipher_after_ip=permutation_string(block_decryption);
                ///key 2 == compressed_key_2
                String split_input_decryption[]=divide_string_to_half(cipher_after_ip);
                String expanded_input_decryption=expand_string(split_input_decryption[1]);

                String xor_operate_data_decryption=xor_data_with_key(expanded_input_decryption,compressed_key_2);

                String after_xor_operation_data_decryption[]=two_halves_data(xor_operate_data_decryption);
                String substitution_first_half_decryption=substitution_s0(after_xor_operation_data_decryption[0]);
                String substitution_second_half_decryption=substitution_s1(after_xor_operation_data_decryption[1]);
                String after_p4_data_decryption=permutation_p4(substitution_first_half_decryption+substitution_second_half_decryption);

                String left_half_decryption=xor_data_with_key(after_p4_data_decryption,split_input_decryption[0]);
                String right_half_decryption=split_input_decryption[1];
                String swapped_string_decryption=right_half_decryption+left_half_decryption;


                ////ROUND 2
                String split_input_decryption_2[]=divide_string_to_half(swapped_string_decryption);
                String expanded_input_decryption_2=expand_string(split_input_decryption_2[1]);
                String xor_operate_data_decryption_2=xor_data_with_key(expanded_input_decryption_2,compressed_key);
                String after_xor_operation_data_decryption_2[]=two_halves_data(xor_operate_data_decryption_2);
                String substitution_first_half_decryption_2=substitution_s0(after_xor_operation_data_decryption_2[0]);
                String substitution_second_half_decryption_2=substitution_s1(after_xor_operation_data_decryption_2[1]);
                String after_p4_data_decryption_2=permutation_p4(substitution_first_half_decryption_2+substitution_second_half_decryption_2);
                String left_half_decryption_2=xor_data_with_key(after_p4_data_decryption_2,split_input_decryption_2[0]);
                String right_half_decryption_2=split_input_decryption_2[1];
                
                String decrypted=permutation_inverse_string(left_half_decryption_2+right_half_decryption_2);
                System.out.println("\nDECRYPTED PLAINTEXT: "+decrypted);
                
                plaintext=plaintext+xor_data_with_key(decrypted,initialization_vector_decryption);
                initialization_vector_decryption=block_decryption;
                
        }
        
        System.out.println("FINAL PLAINTEXT: "+plaintext);
        
        
    }
    public static String permutation_string(String text)
    {
       String txt="";
       for(int i=0;i<ip.length;i++)
       {
          txt=txt+String.valueOf(text.charAt(ip[i]-1));
       }
       return txt;
    }
    public static String permutation_inverse_string(String text)
    {
       String txt="";
       for(int i=0;i<ip_inverse.length;i++)
       {
          txt=txt+String.valueOf(text.charAt(ip_inverse[i]-1));
       }
       return txt;
    }
    public static String permutation_key(String text)
    {
       String txt="";
       for(int i=0;i<p10.length;i++)
       {
          txt=txt+String.valueOf(text.charAt(p10[i]-1));
       }
       return txt;
    }
    public static String expand_string(String text)
    {
        String txt="";
        for(int i=0;i<ep.length;i++)
        {
            txt=txt+String.valueOf(text.charAt(ep[i]-1));
        }
        return txt;
    }
    public static String[] divide_string_to_half(String text)
    {
        String txt[]=new String[2];
        txt[0]=text.substring(0,(text.length()/2));
        txt[1]=text.substring((text.length()/2),text.length());
        return txt;
    }
    public static String xor_data_with_key(String data,String key)
    {
        String txt="";
        for(int i=0;i<data.length();i++)
        {
           if(data.charAt(i)!=key.charAt(i))
               txt=txt+"1";
           else
               txt=txt+"0";
        }
        return txt;
    }
    public static String left_shift(String key)
    {
        String txt;
        
        String first_half_key="";
        String second_half_key="";
        
        for(int i=1;i<key.length()/2;i++)
            first_half_key=first_half_key+String.valueOf(key.charAt(i));
        first_half_key=first_half_key+String.valueOf(key.charAt(0));
        
        for(int i=key.length()/2+1;i<key.length();i++)
            second_half_key=second_half_key+String.valueOf(key.charAt(i));
        second_half_key=second_half_key+String.valueOf(key.charAt(key.length()/2));
        
        txt=first_half_key+second_half_key;
        
        return txt;
    }
    public static String compress_key_to_8_bit(String text)
    {
       String txt="";
       for(int i=0;i<p8.length;i++)
       {
            txt=txt+String.valueOf(text.charAt(p8[i]-1));
       }
       return txt;
    }
    public static String[] two_halves_data(String text)
    {
        String txt[]=new String[2];
        txt[0]=text.substring(0,text.length()/2-1);
        txt[1]=text.substring(text.length()/2,text.length());
        
        return txt;
    }
    public static String substitution_s0(String text)
    {
       String txt="";
       int rowid=Integer.parseInt(String.valueOf(text.charAt(0))+String.valueOf(text.charAt(text.length()-1)),2);
       int colid=Integer.parseInt(String.valueOf(text.charAt(1))+String.valueOf(text.charAt(2)),2);
       
       txt=s0[rowid][colid];
       
       return txt;
    }
    public static String substitution_s1(String text)
    {
       String txt="";
       int rowid=Integer.parseInt(String.valueOf(text.charAt(0))+String.valueOf(text.charAt(text.length()-1)),2);
       int colid=Integer.parseInt(String.valueOf(text.charAt(1))+String.valueOf(text.charAt(2)),2);
       
       txt=s1[rowid][colid];
       
       return txt;
    }
    public static String permutation_p4(String text)
    {
       String txt="";
       for(int i=0;i<p4.length;i++)
       {
            txt=txt+String.valueOf(text.charAt(p4[i]-1));
       }
       return txt;
    
    }
    public static int ceiling_function(String text)
    {
        int ceil_value=0;
          if((text.length()%8)==0)
          {
             ceil_value=text.length()/8;
          }
          else
          {
              ceil_value=(text.length()/8)+1;
          }
        return ceil_value;
    }
}
/*
OUTPUT:
Enter the plaintext: 
10001000111100001010
HOW MUCH PADDING: 4
INPUT TEXT AFTER PADDING: 100010001111000010100000
Enter the key (10 bits): 
1010101011

ENCRYPTION for Block[1]


ROUND 1
permuted_string: 00000000
expanded_string: 00000000
permuted_key: 1101011100
compressed_key: 11100110
xor_operate_data: 11100110

ROUND 2
compressed_key: 01011011
xor_operate_data: 11100101
Encrypted_string: 10001111

ENCRYPTION for Block[2]


ROUND 1
permuted_string: 11101111
expanded_string: 11111111
permuted_key: 1101011100
compressed_key: 11100110
xor_operate_data: 00011001

ROUND 2
compressed_key: 01011011
xor_operate_data: 01110011
Encrypted_string: 11100101

ENCRYPTION for Block[3]


ROUND 1
permuted_string: 11000100
expanded_string: 00101000
permuted_key: 1101011100
compressed_key: 11100110
xor_operate_data: 11001110

ROUND 2
compressed_key: 01011011
xor_operate_data: 01110011
Encrypted_string: 00000101
FINAL ENCRYPTED STRING: 100011111110010100000101

DECRYPTION for Block[1]

DECRYPTED PLAINTEXT: 00000000

DECRYPTION for Block[2]

DECRYPTED PLAINTEXT: 01111111

DECRYPTION for Block[3]

DECRYPTED PLAINTEXT: 01000101
FINAL PLAINTEXT: 100010001111000010100000
*/
























import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.math.BigInteger;
import java.util.Random;
 
public class ISPractical5
{

    static private BigInteger p;
    static private BigInteger q;
    static private BigInteger N;
    static private BigInteger fi;
    static private BigInteger e;
    static private BigInteger d;
    static private int bitlength = 64;
    static private Random     r;

    public void Getinput() throws IOException, Exception{
        r = new Random();
        p = BigInteger.probablePrime(bitlength, r);
        q = BigInteger.probablePrime(bitlength, r);
        N = p.multiply(q);
        fi = p.subtract(BigInteger.ONE).multiply(q.subtract(BigInteger.ONE));
        e = BigInteger.probablePrime(bitlength / 2, r);

        while(fi.gcd(e).compareTo(BigInteger.ONE) > 0 && e.compareTo(fi) < 0)
        {
            e.add(BigInteger.ONE);
        }
        d = e.modInverse(fi);
        
        //DataInputStream in = new DataInputStream(System.in);
        String teststring;
        
        System.out.println("P : "+p);
        System.out.println("Q : "+q);
        System.out.println("N : "+N);
        System.out.println("FI : "+fi);
        System.out.println("E : "+e);
        System.out.println("D : "+d);
        
        System.out.println("---------Public Key Pair-----------\n"+""
                + "(n,e) => "+"("+N+","+e+")");
        
        System.out.println("---------Private Key Pair-----------\n"+""
                + "(d,p,q) => "+"("+d+","+p+","+q+")");
        System.out.println("-----------------------------");
        
        teststring = Getfile();
        
        System.out.println("\n\nEncrypting String: " + teststring);        
 
        // encrypt
        byte[] encrypted = encrypt(teststring.getBytes());
        //System.out.println("encrypting Bytes: " + encrypted);
        String encryp=  new String(encrypted);
        System.out.println("encrypted String: " + encryp);
        
        // decrypt
        byte[] decrypted = decrypt(encrypted);
        System.out.println("Decrypting Bytes: " + decrypted);
        String decryp=  new String(decrypted);
        System.out.println("Decrypted String: " + decryp);
    }
    
    byte[] encrypt(byte[] message){
        return (new BigInteger(message)).modPow(e, N).toByteArray();
    }

    byte[] decrypt(byte[] message){
        return (new BigInteger(message)).modPow(d, N).toByteArray();
    }
    
    String Getfile() throws Exception
    {
        BufferedReader br = null;
        //BufferedWriter bw = null;
        String S = "";
        try {
            br = new BufferedReader(new FileReader("F:\\hello1.txt"));
           
            int num;
            char ch;
            
            while ((num = br.read()) != -1) {
                ch = (char) num;
                if (ch == ' ' || ch == '.' || ch == ',' || ch == ':' || ch == ';'|| ch == '\n') 
                {
                    S += ch;                   
                    //S = "";
                } 
                else 
                {
                    S += ch;
                }
            }
            //bw.write(S);
            System.out.println(S);
            
        } 
        catch (IOException ioe) 
        {
            ioe.printStackTrace();
        }
        br.close();
        return S;
            
    }

}
/*
P : 15538035022582800547
Q : 11884347585561383341
N : 184659409005000120156828672015211487527
FI : 184659409005000120129406289407067303640
E : 2639411549
D : 181044381910545306700759085308460467109
---------Public Key Pair-----------
(n,e) => (184659409005000120156828672015211487527,2639411549)
---------Private Key Pair-----------
(d,p,q) => (181044381910545306700759085308460467109,15538035022582800547,11884347585561383341)
-----------------------------


Encrypting String: Hello pranay.

encryptedString: q:��Yqj�$�)9�
Decrypting Bytes: [B@6d06d69c
Decrypted String: Hello pranay.
*/























import java.awt.Color;
import java.awt.Font;
import javax.swing.*;
import java.awt.event.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.awt.GridLayout;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Map;
import java.util.Random;
import java.util.Scanner;
import java.util.TreeMap;


public class ISPractical7 extends JFrame implements ActionListener
{
    private int key1,key2;
    JFrame Jframe_object,Jframe_object1,Jframe_object2,Jframe_object3;
    JLabel textlabel,textlabel1,textlabel2,MessforEncryp,
            MessEncLabel,MessforDecryp,MessDecLabel,AfterDecLabel,AfterDecMess;
    JTextField textfield,textfield1,textfield2;
    JButton Encryption1,Encryption2,Encryption3, ClearButton,
            DoublecolAndCaesar,DoubleColumnar,CaesarCipher;

    ISPractical7()
    {
        Jframe_object=new JFrame("***Encryption Application***");
        Jframe_object.setVisible(true);
        Jframe_object.setSize(500, 400);
        Jframe_object.setLayout(null);
        Jframe_object.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        //f.setTitle("Registration Form in Java");
        Jframe_object.setResizable(false);
        textlabel = new JLabel("Data for encryption:-");
        textlabel.setForeground(Color.blue);

        textlabel.setFont(new Font("Times New Roman", Font.BOLD, 14));
        textfield = new JTextField();
        Encryption1 = new JButton("Encryption 1");
        Encryption2 = new JButton("Encryption 2");
        Encryption3 = new JButton("Encryption 3");
        ClearButton = new JButton("Clear");
        
        Encryption1.addActionListener(this);
        Encryption2.addActionListener(this);
        Encryption3.addActionListener(this);
        ClearButton.addActionListener(this);
        //l1.setBounds(x,y,width,height);
        
        textlabel.setBounds(10,30,150,30);
        textfield.setBounds(150,30,320,60);  
        Encryption1.setBounds(125,100,250,40);
        Encryption2.setBounds(125,145,250,40);
        Encryption3.setBounds(125,190,250,40);
        ClearButton.setBounds(200,240,100,30);
        Jframe_object.add(textlabel);
        Jframe_object.add(textfield);
        Jframe_object.add(Encryption1);
        Jframe_object.add(Encryption2);
        Jframe_object.add(Encryption3);
        Jframe_object.add(ClearButton);
    }

    @Override
    public void actionPerformed(ActionEvent e)
    {     
        int x = 0;String s1 ;String original;
        if (e.getSource() == Encryption1)
        {
            x++;s1= textfield.getText();original=s1;  
            Jframe_object1=new JFrame("***Encryption 1(DoubleColumnar+Caesar)***");
            Jframe_object1.setVisible(true);
            Jframe_object1.setSize(500, 400);
            Jframe_object1.setLayout(null);
            Jframe_object1.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            //f.setTitle("Registration Form in Java");
            Jframe_object1.setResizable(false);
            
            textlabel1 = new JLabel("Enter key 1:-");
            textlabel1.setForeground(Color.blue);
            textlabel1.setFont(new Font("Times New Roman", Font.BOLD, 14));
            MessEncLabel = new JLabel("Message entered by user:-");
            MessEncLabel.setForeground(Color.blue);
            MessEncLabel.setFont(new Font("Times New Roman", Font.BOLD, 14));
            MessforEncryp = new JLabel(original);
            MessforEncryp.setForeground(Color.blue);
            MessforEncryp.setFont(new Font("Times New Roman", Font.BOLD, 14));
            MessDecLabel = new JLabel("Message After Encryption:-");
            MessDecLabel.setForeground(Color.blue);
            MessDecLabel.setFont(new Font("Times New Roman", Font.BOLD, 14));
            MessforDecryp = new JLabel();
            MessforDecryp.setForeground(Color.blue);
            MessforDecryp.setFont(new Font("Times New Roman", Font.BOLD, 14));
            AfterDecLabel = new JLabel("Message After Decryption:-");
            AfterDecLabel.setForeground(Color.blue);
            AfterDecLabel.setFont(new Font("Times New Roman", Font.BOLD, 14));
            AfterDecMess = new JLabel();
            AfterDecMess.setForeground(Color.blue);
            AfterDecMess.setFont(new Font("Times New Roman", Font.BOLD, 14));
            textlabel2 = new JLabel("Enter key 2:-");
            textlabel2.setForeground(Color.blue);
            textlabel2.setFont(new Font("Times New Roman", Font.BOLD, 14));
            
            textfield1 = new JTextField();
            textfield2 = new JTextField();
            DoublecolAndCaesar = new JButton("Encryption");
            DoublecolAndCaesar.addActionListener(this);
            MessEncLabel.setBounds(10,30,200,30);
            MessforEncryp.setBounds(10,63,400,30);
            textlabel1.setBounds(10,110,150,30);
            textlabel2.setBounds(10,150,150,30);            
            textfield1.setBounds(150,110,320,30);
            textfield2.setBounds(150,150,320,30);
            
            DoublecolAndCaesar.setBounds(150,190,200,20);
            MessDecLabel.setBounds(10, 215, 200, 30);
            MessforDecryp.setBounds(10, 248, 500, 30);
            AfterDecLabel.setBounds(10, 285, 200, 30);
            AfterDecMess.setBounds(10, 318, 500, 30);
            Jframe_object1.add(MessEncLabel);
            Jframe_object1.add(MessforEncryp);
            Jframe_object1.add(textlabel1);
            Jframe_object1.add(textlabel2);
            Jframe_object1.add(textfield1);
            Jframe_object1.add(textfield2);
            Jframe_object1.add(DoublecolAndCaesar);
            Jframe_object1.add(MessDecLabel);
            Jframe_object1.add(MessforDecryp);
            Jframe_object1.add(AfterDecLabel);
            Jframe_object1.add(AfterDecMess);
        }
        if (e.getSource() == Encryption2)
        {
            x++;s1= textfield.getText();original=s1;  
            Jframe_object2=new JFrame("***Encryption 2(Double Columnar)***");
            Jframe_object2.setVisible(true);
            Jframe_object2.setSize(500, 400);
            Jframe_object2.setLayout(null);
            Jframe_object2.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            //f.setTitle("Registration Form in Java");
            Jframe_object2.setResizable(false);
            
            textlabel1 = new JLabel("Enter key 1:-");
            textlabel1.setForeground(Color.blue);
            textlabel1.setFont(new Font("Times New Roman", Font.BOLD, 14));
            MessEncLabel = new JLabel("Message entered by user:-");
            MessEncLabel.setForeground(Color.blue);
            MessEncLabel.setFont(new Font("Times New Roman", Font.BOLD, 14));
            MessforEncryp = new JLabel(original);
            MessforEncryp.setForeground(Color.blue);
            MessforEncryp.setFont(new Font("Times New Roman", Font.BOLD, 14));
            MessDecLabel = new JLabel("Message After Encryption:-");
            MessDecLabel.setForeground(Color.blue);
            MessDecLabel.setFont(new Font("Times New Roman", Font.BOLD, 14));
            MessforDecryp = new JLabel();
            MessforDecryp.setForeground(Color.blue);
            MessforDecryp.setFont(new Font("Times New Roman", Font.BOLD, 14));
            AfterDecLabel = new JLabel("Message After Decryption:-");
            AfterDecLabel.setForeground(Color.blue);
            AfterDecLabel.setFont(new Font("Times New Roman", Font.BOLD, 14));
            AfterDecMess = new JLabel();
            AfterDecMess.setForeground(Color.blue);
            AfterDecMess.setFont(new Font("Times New Roman", Font.BOLD, 14));
            textlabel2 = new JLabel("Enter key 2:-");
            textlabel2.setForeground(Color.blue);
            textlabel2.setFont(new Font("Times New Roman", Font.BOLD, 14));
            
            textfield1 = new JTextField();
            textfield2 = new JTextField();
            DoubleColumnar = new JButton("Encryption");
            DoubleColumnar.addActionListener(this);
            MessEncLabel.setBounds(10,30,200,30);
            MessforEncryp.setBounds(10,63,400,30);
            textlabel1.setBounds(10,110,150,30);
            textlabel2.setBounds(10,150,150,30);            
            textfield1.setBounds(150,110,320,30);
            textfield2.setBounds(150,150,320,30);
            
            DoubleColumnar.setBounds(150,190,200,20);
            MessDecLabel.setBounds(10, 215, 200, 30);
            MessforDecryp.setBounds(10, 248, 500, 30);
            AfterDecLabel.setBounds(10, 285, 200, 30);
            AfterDecMess.setBounds(10, 318, 500, 30);
            Jframe_object2.add(MessEncLabel);
            Jframe_object2.add(MessforEncryp);
            Jframe_object2.add(textlabel1);
            Jframe_object2.add(textlabel2);
            Jframe_object2.add(textfield1);
            Jframe_object2.add(textfield2);
            Jframe_object2.add(DoubleColumnar);
            Jframe_object2.add(MessDecLabel);
            Jframe_object2.add(MessforDecryp);
            Jframe_object2.add(AfterDecLabel);
            Jframe_object2.add(AfterDecMess);
        }
        if (e.getSource() == Encryption3)
        {
            x++;s1= textfield.getText();original=s1;  
            Jframe_object3=new JFrame("***Encryption 3(Caesar)***");
            Jframe_object3.setVisible(true);
            Jframe_object3.setSize(500, 400);
            Jframe_object3.setLayout(null);
            Jframe_object3.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            //f.setTitle("Registration Form in Java");
            Jframe_object3.setResizable(false);
            
            
            MessEncLabel = new JLabel("Message entered by user:-");
            MessEncLabel.setForeground(Color.blue);
            MessEncLabel.setFont(new Font("Times New Roman", Font.BOLD, 14));
            MessforEncryp = new JLabel(original);
            MessforEncryp.setForeground(Color.blue);
            MessforEncryp.setFont(new Font("Times New Roman", Font.BOLD, 14));
            MessDecLabel = new JLabel("Message After Encryption:-");
            MessDecLabel.setForeground(Color.blue);
            MessDecLabel.setFont(new Font("Times New Roman", Font.BOLD, 14));
            MessforDecryp = new JLabel();
            MessforDecryp.setForeground(Color.blue);
            MessforDecryp.setFont(new Font("Times New Roman", Font.BOLD, 14));
            AfterDecLabel = new JLabel("Message After Decryption:-");
            AfterDecLabel.setForeground(Color.blue);
            AfterDecLabel.setFont(new Font("Times New Roman", Font.BOLD, 14));
            AfterDecMess = new JLabel();
            AfterDecMess.setForeground(Color.blue);
            AfterDecMess.setFont(new Font("Times New Roman", Font.BOLD, 14));
           
            CaesarCipher = new JButton("Encryption");
            CaesarCipher.addActionListener(this);
            MessEncLabel.setBounds(10,30,200,30);
            MessforEncryp.setBounds(10,63,400,30);
            
            CaesarCipher.setBounds(150,124,200,40);
            MessDecLabel.setBounds(10, 215, 200, 30);
            MessforDecryp.setBounds(10, 248, 500, 30);
            AfterDecLabel.setBounds(10, 285, 200, 30);
            AfterDecMess.setBounds(10, 318, 500, 30);
            Jframe_object3.add(MessEncLabel);
            Jframe_object3.add(MessforEncryp);
            Jframe_object3.add(CaesarCipher);
            Jframe_object3.add(MessDecLabel);
            Jframe_object3.add(MessforDecryp);
            Jframe_object3.add(AfterDecLabel);
            Jframe_object3.add(AfterDecMess);
        }
        if (e.getSource() == DoublecolAndCaesar)
        {
            String actualmessage=MessforEncryp.getText();
            actualmessage = actualmessage.replaceAll("[^a-zA-Z0-9]", "");
            actualmessage = actualmessage.toLowerCase();
            String key = textfield1.getText();
            String Secondkey = textfield2.getText();
            int len = actualmessage.length();
            System.out.println("length of mess ="+len);
            String encrypt1 = encrypt(actualmessage,key);
            String encrypt2 = encrypt(encrypt1,Secondkey);                
            int Enclen = encrypt2.length();int flag=0;
            System.out.println("length of mess ="+Enclen);
            String Encpart1 = encrypt2.substring(0, Enclen/2);
            String Encpart2 = encrypt2.substring(Enclen/2);
            String encryptedtext1 = CaesarEncryp(Encpart1,flag);
            flag++;
            String encryptedtext2 = CaesarEncryp(Encpart2,flag);
            String FinalEncp = "";   
            FinalEncp =  encryptedtext1 + encryptedtext2;             
            
            //for decryption
            
            System.out.println("Decrypting Plain Text:");
            String Caesardecryp="";char[] cipher = null;
            char[] decrypt = null;String dec1="";String dec2="";
            String Decryptext1 = FinalEncp.substring(0, Enclen/2);
            String Decryptext2 = FinalEncp.substring(Enclen/2);
            if((Enclen/2)%2!=0)
            {
                cipher=new char[Enclen/2];
                decrypt=new char[Enclen/2];
                dec1=CaesarDecryp(Decryptext1.toCharArray(),cipher,decrypt,key1);
                cipher=new char[Enclen/2+1];
                decrypt=new char[Enclen/2+1];
                dec2=CaesarDecryp(Decryptext2.toCharArray(),cipher,decrypt,key2);
            }
            
            if((Enclen/2)%2==0)
            {
                cipher=new char[Enclen/2];
                decrypt=new char[Enclen/2];
                dec1=CaesarDecryp(Decryptext1.toCharArray(),cipher,decrypt,key1);
                dec2=CaesarDecryp(Decryptext2.toCharArray(),cipher,decrypt,key2);
            }
              
            Caesardecryp = dec1+dec2;
            
            String decrypt2 = decrypt(Caesardecryp,Secondkey);
            String decrypt1 = decrypt(decrypt2,key);
            
            System.out.println("\tDemonstration of Double Columnar Transposition:-\n");
            System.out.println("Original Message : "+actualmessage);
            System.out.println("1st Encryption : "+encrypt1);
            System.out.println("2nd Encryption : "+encrypt2);
            System.out.println("Final encryption By Caesar Cipher: "+FinalEncp);
            System.out.println("decryption by caesar : "+Caesardecryp);
            System.out.println("Decryption of 2nd Encryption : "+decrypt2);
            System.out.println("Final Decryption : "+decrypt1);
            MessforDecryp.setText(FinalEncp);
            AfterDecMess.setText(decrypt1);
            try
            {                
                if(actualmessage.length()==0)
                {
                    JOptionPane.showMessageDialog(Encryption1, "No message is entered"); 
                }

                String absoluteFilePath = "F:\\ISPractical7\\hell.txt"; 
                //'true' is used to append in a file.Otherwise old data will be removed.
                BufferedWriter bw = new BufferedWriter(new FileWriter(absoluteFilePath,true));
                String inputdata;
                inputdata = "\nOriginal Message : "+actualmessage+"\n1st Encryption : "+encrypt1+"\n2nd Encryption : "
                        +encrypt2+"\nDecryption of 2nd Encryption : "+decrypt2+"\nFinal Decryption : "+decrypt1;
                //System.out.println("data :-\n"+inputdata);
                bw.write(inputdata);
                bw.close();
                x++;

                if (x > 0)
                {
                    JOptionPane.showMessageDialog(Encryption1, "Data Encrypted Successfully");
                }

            }
            catch(Exception n)
            {
                System.out.println("Exception Caught:-"+n.getMessage());
            }
        }
        if (e.getSource() == DoubleColumnar)
        {
            String actualmessage=MessforEncryp.getText();
            actualmessage = actualmessage.replaceAll("[^a-zA-Z0-9]", "");
            actualmessage = actualmessage.toLowerCase();
            String key = textfield1.getText();
            String Secondkey = textfield2.getText();

            String encrypt1 = encrypt(actualmessage,key);
            String encrypt2 = encrypt(encrypt1,Secondkey);                         
            String decrypt2 = decrypt(encrypt2,Secondkey);
            String decrypt1 = decrypt(decrypt2,key);
            
            System.out.println("\tDemonstration of Double Columnar Transposition:-\n");
            System.out.println("Original Message : "+actualmessage);
            System.out.println("1st Encryption : "+encrypt1);
            System.out.println("2nd Encryption : "+encrypt2);
            System.out.println("Decryption of 2nd Encryption : "+decrypt2);
            System.out.println("Final Decryption : "+decrypt1);
            MessforDecryp.setText(encrypt2);
            AfterDecMess.setText(decrypt1);
            try
            {                
                if(actualmessage.length()==0)
                {
                    JOptionPane.showMessageDialog(Encryption1, "No message is entered"); 
                }
                x++;

                if (x > 0)
                {
                    JOptionPane.showMessageDialog(Encryption1, "Data Encrypted Successfully");
                }

            }
            catch(Exception n)
            {
                System.out.println("Exception Caught:-"+n.getMessage());
            }
        }
        
        if (e.getSource() == CaesarCipher)
        {
            String actualmessage=MessforEncryp.getText();
            actualmessage = actualmessage.replaceAll("[^a-zA-Z0-9]", "");
            actualmessage = actualmessage.toLowerCase();
                      
            int Enclen = actualmessage.length();int flag=0;
            String Encpart1 = actualmessage.substring(0, Enclen/2);
            String Encpart2 = actualmessage.substring(Enclen/2);
            String encryptedtext1 = CaesarEncryp(Encpart1,flag);
            flag++;
            String encryptedtext2 = CaesarEncryp(Encpart2,flag);
            String FinalEncp = "";   
            FinalEncp =  encryptedtext1 + encryptedtext2;             
            
            //for decryption
            
            System.out.println("Decrypting Plain Text:");
            char[] cipher=new char[Enclen/2];
            char[] decrypt=new char[Enclen/2];String Caesardecryp="";
            String Decryptext1 = FinalEncp.substring(0, Enclen/2);
            String Decryptext2 = FinalEncp.substring(Enclen/2);
            String dec1=CaesarDecryp(Decryptext1.toCharArray(),cipher,decrypt,key1);            
            String dec2=CaesarDecryp(Decryptext2.toCharArray(),cipher,decrypt,key2);
            Caesardecryp = dec1+dec2;
            
            
            
            System.out.println("\tDemonstration of Double Columnar Transposition:-\n");
            System.out.println("Original Message : "+actualmessage);
            System.out.println("Final encryption By Caesar Cipher: "+FinalEncp);
            System.out.println("decryption by caesar : "+Caesardecryp);
            MessforDecryp.setText(FinalEncp);
            AfterDecMess.setText(Caesardecryp);
            try
            {                
                if(actualmessage.length()==0)
                {
                    JOptionPane.showMessageDialog(Encryption1, "No message is entered"); 
                }

                
                x++;

                if (x > 0)
                {
                    JOptionPane.showMessageDialog(Encryption1, "Data Encrypted Successfully");
                }

            }
            catch(Exception n)
            {
                System.out.println("Exception Caught:-"+n.getMessage());
            }
        }
        
        else
        {
            textfield.setText("");
        }
    }
    
    
    String encrypt(String message,String key)
    {
        ArrayList<Character[]> al = new ArrayList<>();      
        TreeMap<Character,String> sortedmatrix = new TreeMap<>();
        int s = key.length();
        Character c[] = new Character[s];
        int k=0;       
        for(int i=0;i<message.length();i++)
        {
            c[k++]=message.charAt(i);
            if(k==s || (i==message.length()-1))
            {
                if(k!=s){
                    while(k!=s)
                        c[k++]='x';
                }
                al.add(c);
                k=0;
                
                c = new Character[s];
            }
        }                    
        for(int i=0;i<al.size();i++)
        {
            for(int j=0;j<key.length();j++)
            {
                System.out.print(al.get(i)[j]+" "); 
            }
            System.out.println("");
        }
        
        String forhash= "";
        for(int j=0;j<key.length();j++)
        {
            for(int i=0;i<al.size();i++)
            {
                forhash=forhash+al.get(i)[j];
                sortedmatrix.put(key.charAt(j), forhash);
                
            }
            forhash= "";
        }        
        String encrypto = "";
        for (Map.Entry<Character,String> entry : sortedmatrix.entrySet())
        {            
            encrypto = encrypto+entry.getValue();           
        }             
       return encrypto;        
    }
    
    String decrypt(String cipher , String key)
    {
        String decrypt="";
        int k=0;   
        int col = key.length();int row = cipher.length()/col;
        char [][]dmat= new char[row][col];
        for(int i=0;i <col;i++)
        {
            for(int j=0; j < row ;j++ )
            {
                dmat[j][i]=cipher.charAt(k);
                k++;
            }
        }
        k=0;

        char temp[][]=new char[row][col];
        while(k<col)
        {
            for(int i=0;i <col;i++)
            {
                if(k==col)
                    break;                
                if(i == Character.getNumericValue(key.charAt(k))-1)
                {                   
                    for(int j=0; j < row ;j++ )
                    {                       
                        temp[j][k]=dmat[j][i];          
                    }
                    k++;
                }

            }
        }

        //System.out.println("\nswapped matrix");
        for(int i=0;i <row;i++)
        {
            for(int j=0; j < col ;j++ )
            {
                //System.out.print(""+temp[i][j]+" ");
                decrypt =decrypt+temp[i][j];

            }
            //System.out.println("");
        }
        return decrypt;
    }  
    
    String CaesarEncryp(String preprotext, int flag)
    {
        Random r =new Random();
        char[]encrypt=new char[preprotext.length()];
        char []cipher=preprotext.toCharArray();
        int key = r.nextInt(26);
        if(flag==0)
        {
            key1 =key;
            //System.out.println(""+key1);
        }
        if(flag>0)
        {
            key2 = key;
            //System.out.println(""+key2);
        }
        
        for(int i=0;i<cipher.length;i++)
            encrypt[i]=(char)((((cipher[i]-97)+(int)key)%26)+97);
        String encryption="";
        for(int i=0;i<encrypt.length;i++)
        {
            encryption = encryption + encrypt[i];
            //System.out.print(""+decrypt[i]);
        }
        return encryption;
    }
        
    
    String CaesarDecryp(char[] encrypt,char[] cipher,char[] decrypt,int key)
    {
        for(int i=0;i<cipher.length;i++)
        {
            int val=(encrypt[i]-97-key);
            if(val<0)
                decrypt[i]=(char)((((val+26))%26)+97);
            else
                decrypt[i]=(char)((val%26)+97);
        }
        String decryption="";
        for(int i=0;i<decrypt.length;i++)
        {
            decryption = decryption + decrypt[i];
            //System.out.print(""+decrypt[i]);
        }
            
        
        return decryption;
    }
    
    public static void main(String args[])
    {
        new ISPractical7();

    }
}
























import static ISPracticals.practical6.DHServer.s;

import java.io.*;  
import java.net.*;  
import java.util.Arrays;
import java.util.HashSet;
//import java.util.Random;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeMap;

public class DHClient {
    static int p,g,ya,yb;
    static private int xa;
    public static void main(String[] args) 
    {  
        starting:    
        while(true)
        {          
            try
            {     
                Socket s=new Socket("localhost",6666);                 
                DataOutputStream dout=new DataOutputStream(s.getOutputStream()); 
                DataInputStream dis=new DataInputStream(s.getInputStream());
                System.out.println("Do you want to start Diffie-Hellman"
                        + " Algorithm?\n(Write 'yes' or 'no')");
                Scanner sc=new Scanner(System.in);
                String str=sc.next();
                dout.writeUTF(str);
                String client=dis.readUTF();
                System.out.println("Echo message received from server: "+client);
                if(client.equalsIgnoreCase("ok"))
                {
                    System.out.println("Closing this client....");
                    Thread t =new Thread();
                    t.sleep(2000);
                    dout.flush();  
                    dout.close();  
                    s.close(); 
                    break;
                }
                else
                {
                    System.out.println("---------------------------CLIENT--------------------------------");
                    input();
                    dout.writeInt(p);
                    dout.writeInt(g);
                    code();
                    dout.writeInt(ya);
                    yb = dis.readInt();
                    System.out.println("Server's Yb :  "+yb);
                    System.out.println("");
                    key();
                    dout.flush();  
                    dout.close();  
                    s.close(); 
                    continue starting;
                }                               
            }           
            catch(Exception e)
            {
                e.printStackTrace();
            }  
        }
        
    }
    
    static void input(){
        Scanner sc = new Scanner(System.in);
        System.out.println("----INPUT---");
        do{
            System.out.print("Enter Prime No P :- ");
             p = sc.nextInt();
        }while(primeTest(p)!=true);
        
        try
        {
            if(GetPrimitiveRoot(p)==true)
            {
                System.out.println("Greatest primitive root of P = "+p+" is G = "+ g);
            }
                
            //System.out.println("hi");
            if(GetPrimitiveRoot(p)==false)
            {
                System.out.println("Dear user no primitive root\n"
                        + "Hence,Select a prime No G such that 0<G<P");
                g = sc.nextInt();
                //System.out.println("Greatest primitive root of P = "+p+" is G = "+ g);
            }
            
        }
        catch(Exception e)
        {
            
        }
    }
    
    static void code(){
        System.out.println("\n----------DIFFIE-HELLMAN KEY EXCHANGE--------------\n");
            System.out.println("P : "+p);
            System.out.println("G(biggest primitive root) : "+g);
            System.out.println("");
            
            //Random rand = new Random(); 
             //xa = rand.nextInt(10);
            System.out.println("Enter Client's Secret no.(Xa) :- " );
            xa = s.nextInt();
            //System.out.println("Client's Random Number (Xa) :- " + xa);
            System.out.println("");
            
            ya = (int) (Math.pow(g,xa) % p);
            System.out.println("Client's Ya:  "+ya);
            System.out.println("");
            System.out.println("Waiting for server's response.......");
        
    }
    static void key(){
        int k1 = (int) (Math.pow(yb,xa) % p);
            System.out.println("Client's Secret Key :: "+k1);
    }
    
    static boolean primeTest(int num)
    {
        boolean flag = false;
        for(int i = 2; i <= num/2; ++i)
        {
            if(num % i == 0)
            {
                flag = true;
                break;
            }
        }

        if (!flag)
            return true;
        else
            return false;
    }
    
    static boolean GetPrimitiveRoot(int primeno)
    {    
        Integer distarr[] =new Integer[primeno-1];
        TreeMap<Integer,Integer[]> checkedmatrix = new TreeMap<>();
        for(int i=1;i<primeno;i++)
        {
            System.out.println("i= "+i);
            for(int k=1;k<primeno;k++)
            {
                int temp=(int) (Math.pow(i,k) % primeno);
                System.out.print(temp+" ");
                distarr[k-1]=temp;
            }
            System.out.println("");
            Integer[] temp=new Integer[primeno-1];
            
            //checkedmatrix.put(i,temp);
            //System.out.println("");
            if (areDistinct(distarr)&&primeTest(i))
            {
                System.out.println("\nDistinct array:-");
                for(int j=0;j<distarr.length;j++)
                {    
                    System.out.print(distarr[j]+" ");
                    temp[j]=distarr[j];

                }  
                checkedmatrix.put(i,temp);
                System.out.println("\n");
            }
        }
        
        
        /*for (Map.Entry<Integer,Integer[]> entry : checkedmatrix.entrySet())
        {
            System.out.println("Key = "+entry.getKey()+",Value = " + entry.getValue());            
               
        } */    
        
        //System.out.println("r  :"+g);
        if(checkedmatrix.isEmpty())
        {
             return false;
        }
           
        else
        {
            g=   checkedmatrix.lastKey();
            return true;
        }
            
    }
    
    public static boolean areDistinct(Integer arr[]) 
    { 
        // Put all array elements in a HashSet 
        Set<Integer> s =  new HashSet<Integer>(Arrays.asList(arr)); 
  
        // If all elements are distinct, size of 
        // HashSet should be same array. 
        return (s.size() == arr.length); 
    } 
}  
/*
Do you want to start Diffie-Hellman Algorithm?
(Write 'yes' or 'no')
yes
Echo message received from server: Lets Start!!!
---------------------------CLIENT--------------------------------
----INPUT---
Enter Prime No P :- 71
Enter Prime No G less than P :- 67

----------DIFFIE-HELLMAN KEY EXCHANGE--------------

P : 71
G : 67

Client's Random Number (Xa) :- 0

Client's Ya:  1

Server's Yb :  67

Client's Secret Key :: 1
Do you want to start Diffie-Hellman Algorithm?
(Write 'yes' or 'no')
no
Echo message received from server: ok
Closing this client....
*/






import java.io.*;  
import java.net.*;  
//import java.sql.Time;
//import java.util.Random;
import java.util.Scanner;

public class DHServer 
{  
    static Scanner s = new Scanner(System.in);
    static int p,g,ya,yb;
    static private int xb;
    public static void main(String[] args)
    {  
        starting:
        while(true)
        {
            try
            {  
                System.out.println("---------------------------SERVER--------------------------------");
                ServerSocket ss=new ServerSocket(6666);
                System.out.println("Waiting for Client...");
                Socket s=ss.accept();
                System.out.println("Connection established...");

                DataInputStream dis=new DataInputStream(s.getInputStream());
                DataOutputStream dout=new DataOutputStream(s.getOutputStream());
                String clientmessage=dis.readUTF();
                System.out.println("Message received from client: "+clientmessage);
                
                if(clientmessage.equalsIgnoreCase("no"))
                {
                    System.out.println("Exiting Message sending to client!!! ");
                    dout.writeUTF("ok");
                    Thread t =new Thread();
                    t.sleep(2000);
                    s.close();  
                    break;
                }
                
                if(!clientmessage.equalsIgnoreCase("no"))
                {
                    String servermessage="Lets Start!!!";
                    System.out.println(servermessage);
                    dout.writeUTF(servermessage);
                    p = dis.readInt();
                    g = dis.readInt();
                    ya = dis.readInt();
                    code();

                    System.out.println("Client's Ya :  "+ya);
                    key();
                    System.out.println("");
                    dout.writeInt(yb);
                    dout.flush();  
                    dout.close();  
                    s.close();
                    ss.close();
                   // break;
                    continue starting;
                }
                
                
            }
            catch(Exception e)
            {
                System.out.println(e);
            }  
        }
        
    }  
    
    static void code()
    {
        System.out.println("\n----------DIFFIE-HELLMAN KEY EXCHANGE--------------\n");
        System.out.println("P :- "+p);
        System.out.println("G :- "+g);
        System.out.println("");


        //Random rand = new Random(); 
        //rand.nextInt(10);
        System.out.println("Enter Server's Secret no.(Xb) :- " );
        xb = s.nextInt();
        //System.out.println("Server's Random Number (Xb) :- " + xb);
        
        System.out.println("");

         yb = (int) (Math.pow(g,xb) % p);
        System.out.println("Server's Yb:  "+yb);
        System.out.println("");
        
    }
    static void key()
    {
        int k2 = (int) (Math.pow(ya,xb) % p);
        System.out.println("Server's Secret Key :: "+k2);
        System.out.println("");
    }
}  
/*
run:
---------------------------SERVER--------------------------------
Waiting for Client...
Connection established...
Message received from client: yes
Lets Start!!!

----------DIFFIE-HELLMAN KEY EXCHANGE--------------

P :- 71
G :- 67

Server's Random Number (Xb) :- 1

Server's Yb:  67

Client's Ya :  1
Server's Secret Key :: 1


---------------------------SERVER--------------------------------
Waiting for Client...
Connection established...
Message received from client: no
Exiting Message sending to client!!! 

*/
import java.util.Arrays;
import java.util.HashSet;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeMap;

/**
 *
 * @author PRANAY
 */
public class Primtiveroot 
{
    static int g=0;
    public static void main(String[] args) 
    {
        Scanner sc = new Scanner(System.in);int p ;
        do{
            System.out.print("Enter Prime No P :- ");
            p = sc.nextInt();
        }while(primeTest(p)!=true);
        
        try
        {
            if(GetPrimitiveRoot(p)==true)
            {
                System.out.println("Greatest primitive root of P = "+p+" is G = "+ g);
            }
                
            //System.out.println("hi");
            if(GetPrimitiveRoot(p)==false)
            {
                System.out.println("Dear user no primitive root\n"
                        + "Hence,Select a prime No G such that 0<G<P");
                g = sc.nextInt();
                System.out.println("Greatest primitive root of P = "+p+" is G = "+ g);
            }
            
        }
        catch(Exception e)
        {
            
        }
        
    }
    static boolean GetPrimitiveRoot(int primeno)
    {    
        Integer distarr[] =new Integer[primeno-1];int primitiveroot;
        TreeMap<Integer,Integer[]> checkedmatrix = new TreeMap<>();
        for(int i=1;i<primeno;i++)
        {
            //System.out.println("i= "+i);
            for(int k=1;k<primeno;k++)
            {
                int temp=(int) (Math.pow(i,k) % primeno);
                //System.out.print(temp+" ");
                distarr[k-1]=temp;
            }
            //System.out.println("");
            Integer[] temp=new Integer[primeno-1];
            
            //checkedmatrix.put(i,temp);
            //System.out.println("");
            if (areDistinct(distarr)&&primeTest(i))
            {
                //System.out.println("\nDistinct array:-");
                /*for(int j=0;j<distarr.length;j++)
                {    
                    System.out.print(distarr[j]+" ");
                    temp[j]=distarr[j];

                } */  
                checkedmatrix.put(i,temp);
                //System.out.println("\n");
            }
        }
        
        
        /*for (Map.Entry<Integer,Integer[]> entry : checkedmatrix.entrySet())
        {
            System.out.println("Key = "+entry.getKey()+",Value = " + entry.getValue());            
               
        } */    
        
        //System.out.println("r  :"+g);
        if(checkedmatrix.isEmpty())
        {
             return false;
        }
           
        else
        {
            g=   checkedmatrix.lastKey();
            return true;
        }
            
    }
    
    public static boolean areDistinct(Integer arr[]) 
    { 
        // Put all array elements in a HashSet 
        Set<Integer> s =  new HashSet<Integer>(Arrays.asList(arr)); 
  
        // If all elements are distinct, size of 
        // HashSet should be same array. 
        return (s.size() == arr.length); 
    } 
    static boolean primeTest(int num)
    {
        boolean flag = false;
        for(int i = 2; i <= num/2; ++i)
        {
            if(num % i == 0)
            {
                flag = true;
                break;
            }
        }

        if (!flag)
            return true;
        else
            return false;
    }
    
    
}

